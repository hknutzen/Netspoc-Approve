package linux

import (
	"errors"
	"fmt"
	"os"
	"os/exec"
	"regexp"
	"strings"

	"github.com/hknutzen/Netspoc-Approve/go/pkg/console"
	"github.com/hknutzen/Netspoc-Approve/go/pkg/device"
	"github.com/hknutzen/Netspoc-Approve/go/pkg/sorted"
)

const (
	deviceUser         = "root"
	deviceRoutingFile  = "/etc/network/routing"
	deviceIPTablesFile = "/etc/network/packet-filter"
)

type State struct {
	conn         *console.Conn
	change       change
	ip           string
	user         string
	errUnmanaged []error
}

type change struct {
	routes    []string
	iptables  string
	newConfig *config
}

type config struct {
	iptables tables
	routes   []route
}

func (s *State) LoadDevice(
	spocFile string, cfg *device.Config, logLogin, logConfig *os.File,
) (device.DeviceConfig, error) {
	user, pass := cfg.GetUserPass(device.GetHostname(spocFile))
	var err error
	s.conn, err = console.GetSSHConn(spocFile, user, cfg, logLogin)
	if err != nil {
		return nil, err
	}
	hostName := device.GetHostname(spocFile)
	s.loginEnable(pass, cfg)
	s.logVersion()
	s.checkDeviceName(hostName)
	s.checkBanner(cfg)
	s.conn.SetLogFH(logConfig)
	s.ip, _, _ = device.GetIPPDP(spocFile)
	s.user = user

	return &config{
		iptables: s.getDeviceIPTables(),
		routes:   s.getDeviceRoutes(),
	}, err
}

func (s *State) loginEnable(pass string, cfg *device.Config) {
	conn := s.conn
	stdPrompt := `\r\n\S*\s?[%>$#]\s?(?:\x27\S*)?`
	passPrompt := stdPrompt + `|(?i)password:`
	out := conn.ShortWait(passPrompt + `|\(yes/no.*\)\?`)
	if strings.HasSuffix(out, "?") {
		out = conn.IssueCmd("yes", passPrompt)
	}
	if strings.HasSuffix(out, "word:") {
		out = conn.IssueCmd(pass, passPrompt)
	}
	if strings.HasSuffix(out, "word:") {
		device.Abort("Authentication failed")
	}

	// Force prompt to simple, known value.
	// Don't use '#', because it is used as comment character
	// in output of iptables-save.
	conn.IssueCmd("PS1=router#", stdPrompt)
	rx := regexp.MustCompile(`\nrouter#`)
	conn.SetStdPrompt(rx)
}

func (s *State) logVersion() {
	s.conn.GetCmdOutput("uname -r")
	s.conn.GetCmdOutput("uname -m")
}

func (s *State) checkDeviceName(name string) {
	out := s.conn.GetCmdOutput("hostname -s")
	out = strings.TrimSuffix(out, "\n")
	if name != out {
		device.Abort("Wrong device name: %q, expected: %q", out, name)
	}
}

func (s *State) checkBanner(cfg *device.Config) {
	re := cfg.CheckBanner.String()
	lines := s.conn.GetCmdOutput("grep '" + re + "' /etc/issue")
	if len(lines) == 0 {
		s.errUnmanaged =
			[]error{errors.New("Missing banner at NetSPoC managed device")}
	}
}

func (s *State) getDeviceRoutes() []route {
	out := s.conn.GetCmdOutput("ip route show")
	lines := strings.Split(out, "\n")
	if s := len(lines); s > 0 && lines[s-1] == "" {
		lines = lines[:s-1]
	}
	for i, l := range lines {
		lines[i] = "ip route add " + l
	}
	return parseRoutes(lines)
}

func (s *State) getDeviceIPTables() tables {
	out := s.conn.GetCmdOutput("iptables-save")
	return s.parseIPTables(strings.Split(string(out), "\n"))
}

func (s *State) GetChanges(c1, c2 device.DeviceConfig) error {
	p1 := c1.(*config)
	p2 := c2.(*config)
	s.change = diffConfig(p1, p2)
	return nil
}

func (s *State) HasChanges() bool {
	return len(s.change.routes) != 0 || s.change.iptables != ""
}

func (s *State) ShowChanges() string {
	var collect strings.Builder
	for _, line := range s.change.routes {
		line = strings.Replace(line, "\n", "\\N ", 1)
		fmt.Fprintln(&collect, line)
	}
	if chg := s.change.iptables; chg != "" {
		fmt.Fprintln(&collect, chg)
		fmt.Fprintln(&collect, "#!/sbin/iptables-restore")
		fmt.Fprintln(&collect, "# Generated by NetSPoC")
		for _, line := range getIPTablesConfig(s.change.newConfig.iptables) {
			fmt.Fprintln(&collect, line)
		}
	}
	return collect.String()
}

func (s *State) ApplyCommands(logFh *os.File) error {
	s.conn.SetLogFH(logFh)
	ch := s.change
	cf := ch.newConfig
	// Change active routes on device.
	for _, c := range ch.routes {
		s.cmd(c)
	}
	// Copy new iptables config to temporary file on device.
	// Execute this file to activate new iptables configuration.
	if ch.iptables != "" {
		tmpFile := deviceIPTablesFile + ".new"
		s.writeStartupIPTables(cf.iptables, tmpFile)
		s.cmd("chmod a+x " + tmpFile)
		device.Info("Changing iptables running config")
		s.cmd(tmpFile)
		s.cmd("mv -f " + tmpFile + " " + deviceIPTablesFile)
	}

	// Write startup routing config to device if routes have changed.
	if len(ch.routes) != 0 {
		s.writeStartupRouting(cf.routes, deviceRoutingFile)
	}
	return nil
}

// Send 1 or 2 commands in one data packet to device.
// No output expected from commands.
func (s *State) cmd(c string) {
	c1, c2, _ := strings.Cut(c, "\n")
	s.conn.Send(c)
	check := func(ci string) {
		out := s.conn.GetOutput()
		out = s.conn.StripEcho(ci, out)
		if out != "" {
			device.Abort("Got unexpected output from '%s':\n%s", ci, out)
		}
	}
	check(c1)
	if c2 != "" {
		check(c2)
	}
	if s.conn.GetCmdOutput("echo $?") != "0\n" {
		device.Abort("%s failed (exit status)",
			strings.Replace(c, "\n", "\\N ", 1))
	}
}

func (s *State) writeStartupRouting(routes []route, dst string) {
	file := createTemp("routes")
	defer os.Remove(file.Name())
	lines := []string{"#!/bin/sh", "# Generated by NetSPoC"}
	for _, r := range routes {
		lines = append(lines, r.orig)
	}
	s.writeStartup(file, lines, dst)
}

func (s *State) writeStartupIPTables(tb tables, dst string) {
	file := createTemp("iptables")
	defer os.Remove(file.Name())
	path := s.findIPTablesRestoreCmd()
	tLines := getIPTablesConfig(tb)
	lines := append([]string{"#!" + path, "# Generated by NetSPoC"}, tLines...)
	s.writeStartup(file, lines, dst)
}

func (s *State) findIPTablesRestoreCmd() string {
	out := s.conn.GetCmdOutput("which iptables-restore")
	cmd := strings.TrimSpace(out)
	if !strings.HasSuffix(cmd, "iptables-restore") {
		device.Abort("Can't find path of 'iptables-restore'")
	}
	return cmd
}

func getIPTablesConfig(tb tables) []string {
	var result []string
	for _, tName := range sorted.Keys(tb) {
		chains := tb[tName]
		result = append(result, "*"+tName)
		cNames := sorted.Keys(chains)
		for _, cName := range cNames {
			chain := chains[cName]
			result = append(result, ":"+cName+" "+chain.policy)
		}
		for _, cName := range cNames {
			chain := chains[cName]
			for _, rule := range chain.rules {
				result = append(result, rule.orig)
			}
		}
		result = append(result, "COMMIT")
	}
	return result
}

func createTemp(name string) *os.File {
	file, err := os.CreateTemp("", name)
	if err != nil {
		device.Abort("can't %v", err)
	}
	return file
}

func (s *State) writeStartup(file *os.File, lines []string, dst string) {
	for _, entry := range lines {
		fmt.Fprintln(file, entry)
	}
	file.Close()
	s.putScp(file.Name(), dst)
}

func (s *State) putScp(src, dst string) {
	remote := s.user + "@" + s.ip + ":"
	cmd := exec.Command("scp", "-q", src, remote+dst)
	device.Info("Executing %s", cmd)
	if os.Getenv("SIMULATE_ROUTER") != "" {
		return
	}
	err := cmd.Run()
	if err != nil {
		device.Abort("%s failed: %v", cmd, err)
	}
}

func (s *State) CloseConnection()         {}
func (s *State) GetErrUnmanaged() []error { return nil }
