#!/bin/bash

# Abort on unexpected errors.
set -e

POLICYDB=$(get-netspoc-approve-conf netspocdir)
LOCK=$POLICYDB/LOCK
CURRENT=$POLICYDB/current
NEXT=$POLICYDB/next

msg () {
    echo $@ >&2
}

changes_pending () {
    SRC=$POLICYDB/$POLICY/src
    [ -d $SRC ] || return 0;
    [ -n "$(cvs -n -q update $SRC)" ]
}

show_log () {
    cat $LOG
}

show_log_background () {
    tail -n 1 -f $LOG &
    TAIL_PID=$!
    # $LOG is locked during write.
    # If lock bekomes available, we know that writing has finished.
    flock -s $LOG -c "kill $TAIL_PID"
}

wait_log_available () {
    [ -f $LOG ] && return 0
    sleep 1
    [ -f $LOG ] && return 0
    return 1
}

while true; do
    if [ -L $NEXT ] ; then

        POLICY=$(basename $(readlink $NEXT))
        LOG=$POLICYDB/$POLICY/compile.log


        # Try to get shared lock.
        # Other instances of this script are allowed to get the lock,
        # but newpolicy isn't.
        if flock -n -s 9 ; then
        
            # We got the lock.
            # newpolicy isn't running.
            if ! changes_pending ; then
                
                # No pending changes in repository.
                # Prüfe, ob neueste Policy erfolgreich übersetzt wurde.
                CPOLICY=$(basename $(readlink $CURRENT || true))
                if [ "$POLICY" = "$CPOLICY" ] ; then
                    msg "Newest changeset is already available as current $POLICY"
                else
                    msg "Newest changeset has already been processed as $POLICY,"
                    msg "but processing failed."
                    show_log
                fi 
                exit;
            fi
        else
            
            # newpolicy is already running
            if ! changes_pending ; then
                msg "Newest changeset is currently processed as $POLICY"
                # Check if log is available.
                if wait_log_available ; then
                    show_log_background
                    exit
                fi
                # If log is missing , then possibly newpolicy failed.
                # Restart loop to analyze the new situation.
                continue
            else
                msg "Waiting for processing of $POLICY to be finished"
                show_log_background
                # Start another newpolicy
            fi
        fi
    fi 9<$LOCK 

    newpolicy.pl || status=$?
    if [ "$status" != 2 ] ; then
        exit
    fi

    # Another instance of newpolicy is already running.
    # Restart loop to show that output.
done


